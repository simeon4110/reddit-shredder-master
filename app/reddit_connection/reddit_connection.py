"""
Handles the Reddit connection persistence.
"""

import datetime
import random
import string
import uuid
from datetime import timezone

import praw
import pytz
from django.utils.timezone import timedelta

from Reddit_Shredder.settings import CLIENT_ID
from Reddit_Shredder.settings import CLIENT_SECRET
from Reddit_Shredder.settings import REDIRECT_URI
from Reddit_Shredder.settings import USER_AGENT
from app.logger.exception_decor import exception
from app.logger.exception_logger import logger

# Initialize Reddit object for non-authenticated functions.
reddit = praw.Reddit(client_id=CLIENT_ID,
                     client_secret=CLIENT_SECRET,
                     redirect_uri=REDIRECT_URI,
                     user_agent=USER_AGENT
                     )


@exception(logger)
def delete_comment(id, token, item_type):
    """
    Deletes a specific comment.

    :param id: The comment ID.
    :return: Output from request.
    """
    reddit_refresh = praw.Reddit(client_id=CLIENT_ID,
                                 client_secret=CLIENT_SECRET,
                                 refresh_token=token,
                                 user_agent=USER_AGENT
                                 )

    if item_type == "Submission":
        submission = reddit_refresh.submission(id)
        submission.delete()
        message = "Great Success! Submission deleted!"

    elif item_type == "Comment":
        comment = reddit_refresh.comment(id)
        comment.edit(string_generator())
        comment.delete()
        message = "Great Success! Comment overwritten and deleted!"

    else:
        message = "Not sure what happened."

    return message


@exception(logger)
def get_auth_url():
    """
    Gets a valid auth URL from the Reddit API.

    :return: A valid authorization URL for the Reddit API.
    """
    return reddit.auth.url(['identity,edit,history,read'], uuid.uuid4(),
                           'permanent')


@exception(logger)
def get_token(code):
    """
    Creates a refresh token from an OAuth code.

    :param code: The code returned from the Reddit API.
    :return: A refresh token.
    """
    token = reddit.auth.authorize(code)
    return str(token)


@exception(logger)
def get_reddit_username(token):
    """
    Returns the user's Reddit username.

    :param token: The user's saved refresh token.
    :return: The user's Reddit username.
    """

    reddit_refresh = praw.Reddit(client_id=CLIENT_ID,
                                 client_secret=CLIENT_SECRET,
                                 refresh_token=token,
                                 user_agent=USER_AGENT
                                 )

    return reddit_refresh.user.me()


@exception(logger)
def get_comments(token):
    """
    Returns a comments object from PRAW.

    :param token: The user's saved refresh token.
    :return: A comments object from PRAW.
    """
    reddit_refresh = praw.Reddit(client_id=CLIENT_ID,
                                 client_secret=CLIENT_SECRET,
                                 refresh_token=token,
                                 user_agent=USER_AGENT
                                 )
    return reddit_refresh.user.me().comments.new(limit=None)


@exception(logger)
def get_submissions(token):
    """
    Returns a submissions object from PRAW.

    :param token: The user's refresh token.
    :return: A submissions object from PRAW.
    """
    reddit_refresh = praw.Reddit(client_id=CLIENT_ID,
                                 client_secret=CLIENT_SECRET,
                                 refresh_token=token,
                                 user_agent=USER_AGENT
                                 )
    return reddit_refresh.user.me().submissions.new(limit=None)


@exception(logger)
def string_generator(size=36, chars=string.ascii_letters + string.digits):
    """
    Generates a random string of numbers and letters.

    :param size: The length of the string.
    :param chars: The characters to include (default is letters and numbers.)
    :return: A string of random letters and numbers.
    """
    return "".join(random.choice(chars) for _ in range(size))


@exception(logger)
def delta_now(time):
    """
    Returns delay as time.now - time.

    :param time: The number of hours between now and the delta.
    :return: Now minus the delta.
    """
    delta = datetime.datetime.now(timezone.utc) - timedelta(hours=time)
    return delta


class RedditConnection:
    """
    Class to handle the authenticated connection to Reddit.
    """

    def __init__(self, code, state, time, token):
        """
        Initialize all the needed data.

        :param code: The code returned from the Reddit API.
        :param state: The state generated with uuid4 (generated by
                      get_auth_url.
        :param time:  The time delay for saved posts (if set).
        :param token: The saved refresh token (if one exists).
        """
        self.time = time
        self.code = code
        self.state = state
        self.token = token

        # get token if this is the first run
        if self.token is None:
            self.token = get_token(self.code)

        # otherwise use the token saved in the session / profile
        else:
            self.token = token

    def return_token(self):
        """
        :return: The token saved in this object.
        """
        return self.token

    def get_data(self, user=False, comments=False, submissions=False):
        """
        Gets the data from the Reddit API via an authenticated praw.reddit
        object. This is used to keep the session open and reduce API calls.

        :param user: If True, return username.
        :param comments: If True, return comments.
        :param submissions: If True, return submissions.
        :return: Depends on which flag is set.
        """

        reddit_refresh = praw.Reddit(client_id=CLIENT_ID,
                                     client_secret=CLIENT_SECRET,
                                     refresh_token=self.token,
                                     user_agent=USER_AGENT
                                     )

        if user is True:
            return reddit_refresh.user.me()

        if comments is True:
            return reddit_refresh.user.me().comments.new(limit=None)

        if submissions is True:
            return reddit_refresh.user.me().submissions.new(limit=None)

    def shredder(self):
        """
        Shredder Actual - deletes a users posts and submissions based off
        the parameters passed in the __init__ section.

        :return: Output from the shredder, detailing which posts are deleted
                 or skipped.
        """
        # stores the output from the shredding process.
        output = []
        skipped_count = 0
        deleted_count = 0

        # overwrites and deletes a user's comments.
        for comment in self.get_data(comments=True):

            # Get the comment creation time.
            time = datetime.datetime.fromtimestamp(comment.created)
            time = time.replace(tzinfo=pytz.utc)

            # this overwrites the comment, saves it and deletes it
            if time < delta_now(self.time):
                comment_before = comment.body
                comment.edit(string_generator())
                data = comment.id, comment_before, "DELETED"
                output.append(data)
                deleted_count += 1
                comment.delete()

            # skip the comment
            else:
                data = comment.id, comment.body, "SKIPPED"
                skipped_count += 1
                output.append(data)

        # deletes a user's subs.
        for submission in self.get_data(submissions=True):
            # Get the submission creation time.
            time = datetime.datetime.fromtimestamp(submission.created)
            time = time.replace(tzinfo=pytz.utc)

            # delete the submission
            if time < delta_now(self.time):
                data = submission.id, submission.title, "DELETED"
                output.append(data)
                deleted_count += 1
                submission.delete()

            # skip the submission
            else:
                data = submission.id, submission.title, "SKIPPED"
                skipped_count += 1
                output.append(data)

        # returns the output
        return output, skipped_count, deleted_count
